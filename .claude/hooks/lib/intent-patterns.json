{
  "_comment": "Intent Patterns Library - Generic architectural patterns for prompt enhancement",
  "_version": "1.0.0",
  "_usage": "Used by prompt-enhancer.js to detect user intent and translate to technical architecture",
  "_author": "legal-braniac",
  "_updatedAt": "2025-11-16",

  "patterns": [
    {
      "id": "mass-data-collection",
      "intent": "(baixar|download|scrape|coletar|extrair).*(massa|lote|bulk|grande quantidade|múltiplos)",
      "architecture": "API_SCRAPING_STORAGE",
      "components": [
        "api-client (with retry logic)",
        "rate-limiter (respect API quotas)",
        "data-parser (normalize formats)",
        "storage-layer (scalable persistence)",
        "error-handler (resume on failure)"
      ],
      "translation": "Sistema de coleta em massa requer:\n  1. Cliente API com rate limiting e retry\n  2. Parser de dados para normalização\n  3. Storage escalável (considere chunking para grandes volumes)\n  4. Error handling robusto para retomar de falhas",
      "questions": [
        "Qual a fonte de dados? (API REST, scraping HTML, arquivos, outro)",
        "Volume estimado? (centenas, milhares, milhões)",
        "Formato de saída? (JSON, CSV, banco de dados)"
      ]
    },
    {
      "id": "monitor-notify",
      "intent": "(monitorar|acompanhar|vigiar|watch).*(alertar|notificar|avisar)",
      "architecture": "POLLING_NOTIFICATION",
      "components": [
        "scheduler (cron/interval)",
        "diff-detector (state comparison)",
        "notification-service (email/webhook/etc)",
        "state-storage (track last known state)"
      ],
      "translation": "Sistema de monitoramento requer:\n  1. Scheduler para polling periódico\n  2. Detector de mudanças (diff entre estados)\n  3. Serviço de notificação (email, SMS, webhook)\n  4. Storage de estado para comparação",
      "questions": [
        "Frequência de verificação? (tempo real, minutos, horas, diário)",
        "Canal de notificação? (email, SMS, webhook, log)",
        "O que caracteriza uma mudança relevante?"
      ]
    },
    {
      "id": "data-transformation",
      "intent": "(transformar|converter|processar|mapear).*(dados|arquivo|formato)",
      "architecture": "ETL_PIPELINE",
      "components": [
        "extractor (read source)",
        "transformer (business logic)",
        "loader (write destination)",
        "validator (data quality)"
      ],
      "translation": "Pipeline de transformação requer:\n  1. Extractor para ler fonte de dados\n  2. Transformer com lógica de negócio\n  3. Loader para destino\n  4. Validator para garantir qualidade",
      "questions": [
        "Formato de entrada? (CSV, JSON, XML, outro)",
        "Regras de transformação? (mapeamento, cálculos, filtros)",
        "Formato de saída? (CSV, JSON, banco de dados)"
      ]
    },
    {
      "id": "api-integration",
      "intent": "(integrar|conectar|consumir).*(api|serviço|endpoint)",
      "architecture": "API_CLIENT_WRAPPER",
      "components": [
        "http-client (requests library)",
        "auth-handler (API keys, OAuth, etc)",
        "response-parser (handle API formats)",
        "cache-layer (optional, reduce API calls)"
      ],
      "translation": "Integração com API requer:\n  1. Cliente HTTP com autenticação\n  2. Parser de respostas\n  3. Error handling para status codes\n  4. Cache opcional para reduzir chamadas",
      "questions": [
        "API pública ou privada? (autenticação necessária?)",
        "Rate limits da API? (quota por minuto/hora/dia)",
        "Formato de resposta? (JSON, XML, outro)"
      ]
    },
    {
      "id": "automated-testing",
      "intent": "(testar|validar|verificar).*(automaticamente|automático|auto)",
      "architecture": "TEST_AUTOMATION",
      "components": [
        "test-runner (pytest, jest, etc)",
        "test-cases (unit, integration, e2e)",
        "assertions (expected vs actual)",
        "reporting (test results)"
      ],
      "translation": "Automação de testes requer:\n  1. Framework de testes (pytest, jest, etc)\n  2. Test cases organizados (unit, integration, e2e)\n  3. Assertions claras\n  4. Reporting de resultados",
      "questions": [
        "Tipo de testes? (unitários, integração, e2e, todos)",
        "Framework preferido? (pytest, unittest, jest, outro)",
        "Coverage alvo? (percentual mínimo)"
      ]
    },
    {
      "id": "dashboard-visualization",
      "intent": "(dashboard|visualizar|exibir|mostrar).*(dados|métricas|estatísticas|gráficos)",
      "architecture": "FRONTEND_DASHBOARD",
      "components": [
        "backend-api (data endpoints)",
        "frontend-framework (React, Vue, etc)",
        "chart-library (D3, Chart.js, etc)",
        "state-management (Redux, Context, etc)"
      ],
      "translation": "Dashboard requer:\n  1. Backend API para dados\n  2. Frontend framework (React, Vue, etc)\n  3. Biblioteca de gráficos (Chart.js, D3)\n  4. State management",
      "questions": [
        "Stack preferida? (React, Vue, Svelte, outro)",
        "Tipo de visualizações? (linha, barra, pizza, mapa, outro)",
        "Atualização? (tempo real, on-demand, periódica)"
      ]
    },
    {
      "id": "batch-processing",
      "intent": "(processar|executar|rodar).*(lote|batch|múltiplos|vários).*(arquivo|item|registro)",
      "architecture": "BATCH_PROCESSOR",
      "components": [
        "job-queue (task distribution)",
        "worker-pool (parallel processing)",
        "progress-tracker (status monitoring)",
        "result-aggregator (consolidate outputs)"
      ],
      "translation": "Processamento em lote requer:\n  1. Fila de jobs\n  2. Worker pool para paralelização\n  3. Tracker de progresso\n  4. Agregador de resultados",
      "questions": [
        "Volume de processamento? (dezenas, centenas, milhares)",
        "Processamento paralelo? (quantos workers simultâneos)",
        "Priorização? (FIFO, prioridades, dependências)"
      ]
    },
    {
      "id": "report-generation",
      "intent": "(gerar|criar|produzir).*(relatório|report|documento|arquivo)",
      "architecture": "REPORT_GENERATOR",
      "components": [
        "data-aggregator (collect data)",
        "template-engine (report layout)",
        "renderer (PDF, HTML, Excel)",
        "scheduler (optional, periodic reports)"
      ],
      "translation": "Geração de relatórios requer:\n  1. Agregador de dados\n  2. Template engine (Jinja, Handlebars, etc)\n  3. Renderer (PDF, HTML, Excel)\n  4. Scheduler opcional para relatórios periódicos",
      "questions": [
        "Formato de saída? (PDF, HTML, Excel, outro)",
        "Periodicidade? (on-demand, diário, semanal, mensal)",
        "Template customizável? (usuário pode modificar layout)"
      ]
    },
    {
      "id": "authentication-system",
      "intent": "(autenticação|login|autenticar|auth|acesso).*(usuário|user|sistema)",
      "architecture": "AUTH_SYSTEM",
      "components": [
        "user-model (database schema)",
        "password-hasher (bcrypt, argon2, etc)",
        "session-manager (JWT, cookies, etc)",
        "auth-middleware (protect routes)"
      ],
      "translation": "Sistema de autenticação requer:\n  1. Modelo de usuário (schema de banco)\n  2. Hash de senhas (bcrypt, argon2)\n  3. Gerenciador de sessões (JWT, cookies)\n  4. Middleware de proteção de rotas",
      "questions": [
        "Tipo de autenticação? (JWT, session-based, OAuth)",
        "Funcionalidades? (registro, login, recuperação de senha, 2FA)",
        "Níveis de acesso? (roles, permissions)"
      ]
    },
    {
      "id": "data-validation",
      "intent": "(validar|verificar|checar).*(dados|entrada|input|formulário)",
      "architecture": "VALIDATION_LAYER",
      "components": [
        "schema-validator (Joi, Yup, Pydantic, etc)",
        "sanitizer (clean inputs)",
        "error-formatter (user-friendly messages)",
        "custom-validators (business rules)"
      ],
      "translation": "Camada de validação requer:\n  1. Schema validator (Joi, Yup, Pydantic)\n  2. Sanitizer para limpar inputs\n  3. Formatador de erros amigáveis\n  4. Validators customizados para regras de negócio",
      "questions": [
        "Tipo de dados? (formulários web, API requests, arquivos)",
        "Validações necessárias? (tipo, formato, range, obrigatoriedade)",
        "Feedback ao usuário? (inline, toast, modal)"
      ]
    },
    {
      "id": "caching-layer",
      "intent": "(cache|cachear|armazenar temporariamente).*(dados|resultado|resposta)",
      "architecture": "CACHING_LAYER",
      "components": [
        "cache-backend (Redis, Memcached, in-memory)",
        "cache-key-generator (unique identifiers)",
        "ttl-manager (expiration logic)",
        "invalidation-strategy (when to clear)"
      ],
      "translation": "Sistema de cache requer:\n  1. Backend de cache (Redis, Memcached, in-memory)\n  2. Gerador de chaves únicas\n  3. Gerenciador de TTL (time-to-live)\n  4. Estratégia de invalidação",
      "questions": [
        "Backend preferido? (Redis, Memcached, in-memory)",
        "TTL padrão? (segundos, minutos, horas)",
        "Invalidação? (manual, automática, por evento)"
      ]
    },
    {
      "id": "search-functionality",
      "intent": "(buscar|pesquisar|procurar|search|find).*(dados|conteúdo|registros)",
      "architecture": "SEARCH_ENGINE",
      "components": [
        "indexer (build search index)",
        "query-parser (parse user queries)",
        "ranking-algorithm (relevance scoring)",
        "search-backend (Elasticsearch, database FTS, etc)"
      ],
      "translation": "Funcionalidade de busca requer:\n  1. Indexador (construir índice de busca)\n  2. Parser de queries\n  3. Algoritmo de ranking (relevância)\n  4. Backend (Elasticsearch, PostgreSQL FTS, etc)",
      "questions": [
        "Volume de dados? (milhares, milhões, bilhões)",
        "Tipo de busca? (exata, fuzzy, full-text, facetada)",
        "Backend? (Elasticsearch, PostgreSQL FTS, in-memory)"
      ]
    }
  ]
}
